package main

import (
	"fmt"
)

/*
Вся соль кроется в использовании именнованной переменной в функции test. Это я заметил когда дебажил код,
используя Delve. Для функции anotherTest в переменных выдяется регистр r0 который используется для
возврата значения и значение ему присваевается в момент return statement.

Мы копируем из x в r0 значение x, которое на тот момент равно 1, а как мы знаем defer отрабатывает после
return statement, поэтому после вызова defer переменная x примет значение 2, что логично, но r0 уже не обновится.

А в случае функции test, переменная x именованная и для нее не требуется временного регистра r0
и ведет себя как полноценная переменная, только в области видимости функции test и может быть
изменена в defer, поэтому после вызова defer переменная x примет значение 2 и вернет именно его.

Мы заключаем "контракт" и говорим, вот есть эта переменная ее нужно вернуть, но после всех деферов она может измениться

Деферы выполняются в обратном порядке, а итоговый вывод после anotherTest() будет 1, а после test() будет 2.
*/

func anotherTest() int {
	var x int
	defer func() {
		x++
	}()
	x = 1
	return x
}

func test() (x int) {
	defer func() {
		x++
	}()
	x = 1
	return x
}

func main() {
	fmt.Println(anotherTest())
	fmt.Println(test())
}
